/*
  License: zlib license

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.
*/

/// \file
///
/// balancedgen_t generates uint32_t numbers. Each successive call
/// to next balancedgen_next will return numbers in a tree fashion
/// starting at MAX_BALANCEDID/2.
///
/// For instance, if MAX_BALANCEDID was equals to 8, the calls to
/// next_id would return in the sequence:
/// 
///           4
///       /       \
///      2         6
///    /   \     /   \
///   1     3   5     7
///
/// The sequence: 4, 2, 6, 1, 3, 5, 7.
/// It is also important to notice that neither 0 or MAX_BALANCEDID
/// are generated ids.
///
#ifndef IDGEN_BALANCEDID_H_
#define IDGEN_BALANCEDID_H_

#include<stdint.h>
#include<stdbool.h>
#include<stdlib.h>

///
/// The id = 0 will never be generated.
///
#define BALANCEDID_NULL_ID 0

///
/// The highest id that will be generated by the
/// 32 bits id generator: 2^31.
///
#define MAX_BALANCEDID (((uint32_t) 1) << 31)

//
// Returns true if the id is balancedgen_t valid/generated id.
//
#define balancedid_isvalid(id) ((id) != BALANCEDID_NULL_ID)

///
/// Frees a balancedgen_t* created using balancedgen_new() or
/// using C's malloc.
///
#define balancedgen_delete(ptr) free(ptr)

typedef struct {
    /// the current tree depth
    uint32_t _tree_level;
    /// The index of the id that will be generated next. For
    /// instace, at the second level (tree_depth = 1) two ids
    /// (2^1) will be generated, thus 'index' tells whether
    /// it's the first or the second id
    uint32_t _index;
    /// the base value that will be multiplied in order to
    /// generate the new id
    uint32_t _seed;
    /// If done = 1, the generator has been exausted and should
    /// be freed.
    bool _done;
} balancedgen_t;

/// 
/// Returns an initialized balancedgen_t.
/// \return an initialized balancedgen_t.
/// 
balancedgen_t balancedgen_make();

/// 
/// Creates a new balancedgen_t and initialized.
/// \return a new balancedgen_t.
/// 
balancedgen_t* balancedgen_new();

/// 
/// Generates a new id. If the generator has been exhausted,
/// it'will return BALANCEDID_NULL_ID.
/// 
/// \param g a pointer to balancedid_s.
/// \return a uint32_t valid id or BALANCEDID_NULL_ID if the
///         generator has been exhausted.
/// 
uint32_t balancedgen_next(balancedgen_t *restrict g);

/// 
/// Make the balancedgen_t brand new again!
/// \param g a pointer to balancedgen_t.
/// 
void balancedgen_reset(balancedgen_t *restrict g);

#endif // IDGEN_BALANCEDID_H_
